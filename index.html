<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Francisco Zacarias</title>

  <!-- For building trees -->
  <script type="module">
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ startOnLoad: true });
  </script>
</head>

<header>
  <nav>
    <a href="#home" data-page="home" class="nav-link active">Home</a>
    <a href="#projects" data-page="projects" class="nav-link">Projects</a>
    <a href="#cv" data-page="cv" class="nav-link">Professional Experience</a>
    <a href="#blog" data-page="blog" class="nav-link">Blog</a>
  </nav>
</header>

<body>
  <main id="content">
    <section id="home" class="page">
      <h1>Welcome</h1>
      <p>
        Hello! I'm Francisco. I'm a programmer passionate about low-level, engines, tools and games.
        I mainly enjoy working in C and developing systems from scratch.
        I work as a tools programmer in the videogame industry.
      </p>

      <h2>Featured Projects</h2>
      <a href="#projects" data-page="projects" class="nav-link">Check projects page</a>
      <ul>
        <li>
          <strong>OpenGL and C Project</strong>: 3D world with interactive cubes, selection, translation, and color changes.
          <a href="https://github.com/FranciscoZacarias/noname" target="_blank">View on GitHub</a>.
        </li>
        <li>
          <strong>Algorithm Visualizer</strong>: Interactive tool to visualize pathfinding and maze algorithms.
          <a href="https://github.com/FranciscoZacarias/Algorithm-Visualizer-JavaFX" target="_blank">View on GitHub</a>.
        </li>
      </ul>

      <h2>Blog Topics</h2>
      <a href="#blog" data-page="blog" class="nav-link">Check my blog</a>
      <ul>
        <li>
          <strong>Hephaestus - A table driven code generator</strong>: My code generation tool.
          <a href="https://github.com/FranciscoZacarias/hephaestus" target="_blank">View on GitHub</a>.
        </li>
        <li>
          <strong>Developing my C codebase</strong>: A short look at the C code base that I have been developing by myself.
          <a href="https://github.com/FranciscoZacarias/fz_std" target="_blank">View on GitHub</a>.
        </li>
      </ul>

      <hr>

      <a href="#cv" data-page="cv" class="nav-link">Also, check my professional experience ;)</a>
    </section>

    <section id="projects" class="page" style="display:none;">
      <h1>Projects</h1>
      <p>Some of my personal projects developed independently:</p>
      <hr>
      <ul>
        <li>
          <strong>Immediate mode UI in C</strong>:
          <a href="https://github.com/FranciscoZacarias/fz_ui" target="_blank" >github</a>
          <p>
            I developed a rough prototype for an immediate mode UI in C. This was my second iteration of the prototype,
            where I tried to use a different approach to the underlying UI tree. Essentially, each node of the tree is a quad
            with some optionally displayed text, and each node has functionality that can be attached to it. 
            With this approach, building widgets becomes almost a scripting task - you just create nodes and attach functionality to them.
          </p>
          <p>A UI window with some buttons and checkboxes</p>
          <img src="assets/project_showcase/fz_ui.PNG" alt="fz_ui window" class="cv-gif">
          <p>A UI window with debug enabled. While keeping in mind that every quad is a node with optional text, here you can see:</p>
          <ol>
            <li> Node boundries and clip quad. In most nodes here, the clip is slithgly smaller due to padding added.</li>
            <li> Buttons, Labels and checkboxes. </li>
            <li> Each node's cursor (defined with a small X), that shows where the next child of this node would've been drawn. </li>
            <li> Vertical and horizontal layouts.</li>
          </ol>
          <img src="assets/project_showcase/fz_ui_boundries.PNG" alt="fz_ui window boundries" class="cv-gif">
          <p>The following code is how you define this window in the application space:</p>
          <pre><code class="language-c">// Booleans defined in the global scope for the checkboxes:
global b32 a = false;
global b32 b = false;
global b32 c = false;

...

entry_point()
{
  while (1)
  {
    // ...

    ui_top_left(vec2f32(200,200))
    ui_size_fixed_x(x) ui_size_fixed_y(y)
    ui_window(S("Test Window"))
    {
      ui_padding_fixed(5)
      ui_row(S("Test Row"), 100)
      {
        ui_label(S("Label"));
        ui_button(S("Button 1"));
        ui_checkbox(S("Checkbox a"), &a);
        ui_checkbox(S("Checkbox b"), &b);
      }
      ui_padding_fixed(5)
      ui_row(S("Test Row 2"), 100)
      {
        ui_checkbox(S("Checkbox a"), &a);
      }
      ui_padding_fixed(5)
      ui_column(S("Test column"), 200)
      {
        ui_label(S("More checkboxes"));
        ui_checkbox(S("Checkbox b"), &b);
        ui_checkbox(S("Checkbox c"), &c);
      }
    }
    ui_end();
    
    // ...
  }
}</code></pre>
        </li>
        <hr>
        <li>
          <strong>OpenGL and C Project</strong>:
          <a href="https://github.com/FranciscoZacarias/noname" target="_blank">github</a>
          <a href="https://www.youtube.com/watch?v=EnGcnkr7cwQ" target="_blank">video showcase</a>
          <p>
            My first OpenGL project that also tests my first iteration of my codebase.
            It presents a 3D world with a small number of cubes that can be created,
            deleted, selected, translated, and change color.
          </p>
          <img src="assets/project_showcase/opengl_c_project.gif" alt="OpenGL demo" class="cv-gif">
        </li>
        <hr>
        <li>
          <strong>C Codebase</strong>:
          <a href="https://github.com/FranciscoZacarias/fz_std" target="_blank">github</a>.
          <p>My handwritten and everchanging <code>C</code> codebase that I use in every C project. In many aspects a more sane foundation than the CLib to work on. </p>
          <p>Find more in my <a href="#blog" data-page="blog" class="nav-link">blog</a>.</p>
          <p>Example opengl project using this codebase: </p>
          <pre><code>#include "fz_base.h"

function void
input_update()
{
  if (input_is_key_pressed(Keyboard_Key_ESCAPE))
  {
    os_exit_process(0);
  }
}

function void
entry_point(Command_Line* command_line)
{
  Arena* arena = arena_alloc();

  os_console_init();
  os_window_init(400, 400, S("fz_std_tests"));
  os_opengl_init();
  os_window_open();

  f32 phase = 0.0f;
  const f32 speed = 0.05f;
  const f32 tau = PI*2;

  os_window_enable_vsync(true);
  while(os_is_application_running())
  {
    input_update();

    phase += speed;
    if (phase > tau) phase -= tau;
    f32 t = (1.0f + cosf(phase)) * 0.5f;
    f32 r = (1.0f + cosf(phase)) * 0.5f;
    f32 g = (1.0f + cosf(phase - tau/3)) * 0.5f;
    f32 b = (1.0f + cosf(phase - 2*tau/3)) * 0.5f;
    glClearColor(r, g, b, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

    os_swap_buffers();
  }
}</code></pre>
        </li>
        <hr>
        <li>
          <strong>My code generator - Hephaestus</strong>:
          <a href="https://github.com/FranciscoZacarias/hephaestus" target="_blank">github</a>.
          <p>
            A table driven code generation tool capable of generating any type of structured text.
            This tool eliminates my need for any type of compile time code generation in C, since I can generate anything I want
            up front, where the most recurrent usecase is implementing data structures that encode diffrent data types.
          </p>
          <p>Find more in my <a href="#blog" data-page="blog" class="nav-link">blog</a>.</p>
          <p>Generating multiple stack data structures for my UI system - without resorting to templates.</p>
          <pre><code>@table // Defines stacks for different types
Stack_Table (name type default_value max)
{
  { node              UI_Node*             (UI_Node){0}                   32 }
  { top_left          Vec2f32              `vec2f32(0.0f, 0.0f)`          32 }
  { size_x            f32                   g_os_window.dimensions.x      32 }
}

@generate
{
  `// @Hephaestus generated code $(@time_now) \n\n`
  @foreach(Stack_Table) `// Row $(@index)\ntypedef struct $(name) $(name);\nstruct $(name)_stack\n{\n  $(type) data[$(max)];\n  u32 top_index;\n  $(type) bottom_val;\n};\n\n\n`
}</code></pre>
          <p>Generates:</p>
          <pre><code>// @Hephaestus generated code 2025-October-08 15:53:23 

// Row 0
typedef struct node node;
struct node_stack
{
  UI_Node* data[32];
  u32 top_index;
  UI_Node* bottom_val;
};

// Row 1
typedef struct top_left top_left;
struct top_left_stack
{
  Vec2f32 data[32];
  u32 top_index;
  Vec2f32 bottom_val;
};

// Row 2
typedef struct size_x size_x;
struct size_x_stack
{
  f32 data[32];
  u32 top_index;
  f32 bottom_val;
};</code></pre>
        </li>
        <hr>
        <li>
          <strong>C and Opengl 3D prototyping renderer template</strong>:
          <a href="https://github.com/FranciscoZacarias/fz_render_3d" target="_blank">github</a>.
          <p>My Opengl and C 3D renderer (that uses instancing and batching) that I use as a template for graphical projects. It draws basic 3D primitives with colors and/or textures and supports text rendering. Good for just prototyping. </p>
          <p>Example project:</p>
          <pre><code>function void
entry_point(Command_Line* command_line)
{
  Arena* arena = arena_alloc();

  os_console_init();
  os_window_init(400, 400, PROJECT_NAME, &input);
  os_opengl_init();
  os_window_open();

  String8 project_path = os_executable_path(arena);
  project_path = os_directory_pop(project_path); // Pop *.exe
  project_path = os_directory_pop(project_path); // Pop from build/

  // Renderer
  r_init();

  // Camera
  camera3d_init(&g_camera, 8.0f);
  g_camera.position = vec3f32(-1.0f, 1.0f, 5.0f);
  camera3d_look_at(&g_camera, vec3f32(0.0f, 0.0f, 0.0f));

  // Time
  g_frame_timer = os_timer_start();

  // Frame arena
  Arena* frame_arena = arena_alloc();
  u64 frame_arena_initial_position = frame_arena->position;

  g_tex_black = r_load_texture(string8_concat(arena, project_path, S("\\assets\\textures\\prototype\\black.png")));
  g_tex_red   = r_load_texture(string8_concat(arena, project_path, S("\\assets\\textures\\prototype\\red.png")));
  g_tex_color_blue = r_create_color_texture(COLOR_BLUE(1.0f));
  g_tex_color_yellow = r_create_color_texture(COLOR_YELLOW(1.0f));

  while(os_is_application_running(&input))
  {
    // Begin frame
    {
      g_delta_time = (f32)os_timer_seconds(&g_frame_timer);
      g_fps = 1.0f / g_delta_time;
      g_frame_counter += 1;
      os_timer_reset(&g_frame_timer);
    }

    input_update();
    simulation(frame_arena);
    r_render(camera3d_get_view_matrix(&g_camera), mat4f32_perspective(g_camera.fov, g_os_window.dimensions.x, g_os_window.dimensions.y, 0.1f, 100.0f));

    // Close frame
    {
      arena_pop_to(frame_arena, frame_arena_initial_position);
    }
  }
}</code></pre>
          <p>Demo</p>
          <img src="assets/project_showcase/fz_render_3d.gif" alt="odin-waveformat" class="cv-gif">
        </li>
        <hr>
        <li>
          <strong>Odin simple parser for waveformat (.obj) </strong>:
          <a href="https://github.com/FranciscoZacarias/noname-odin" target="_blank">github</a>.
          <p>A simple and limited parser for waveformat (.obj) mesh format to learn the Odin language. <a href="#">link</a>.</p>
          <p>Here is Suzanne Mesh showcase from this small project:</p>
          <img src="assets/project_showcase/odin_waveformat.png" alt="odin-waveformat" class="cv-gif">
        </li>
        <hr>
        <li>
          <strong>Algorithm visualizer in Java</strong>:
          <a href="https://github.com/FranciscoZacarias/Algorithm-Visualizer-JavaFX" target="_blank">github</a>
          <a href="https://www.youtube.com/watch?v=AfZ-rd4iG1E" target="_blank">video showcase</a>
          <p>JavaFX project to visualize pathfinding and maze generation algorithms. This was one of my first personal projects ever - which used JavaFX (eventhough these days I try to write my own renderer).</p>
          <p>Here is a showcase of two visualizations of pathfinding and maze generation algorithms</p>
          <img src="assets/project_showcase/weightdijkstra.gif" alt="pathfinding" class="cv-gif">
          <img src="assets/project_showcase/backtracker.gif" alt="maze-generation" class="cv-gif">
        </li>
        <hr>
      </ul>
    </section>

    <section id="cv" class="page" style="display:none;">
      <h1>Professional experience </h1>
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <a href="assets/FranciscoBelchiorZacarias_CV.pdf" download class="download-btn">PDF Version (august/2024)</a>
      </div>

      <div>
        <h4>Tools Programmer - GRIP Studios</h4>
        <p><em>February 2025 – Present | Prague, Czech Republic</em></p>
        <ul>
          <li>Gameplay programming for an unnanounced project (2).</li>
          <li>Working on a city building tool for an unnanounced project (1).</li>
        </ul>
      </div>

      <div>
        <h4>Tools Programmer - Toadman Interactive</h4>
        <p><em>November 2023 – January 2025 | Berlin, Germany</em></p>
        <ul>
          <li>Developed a Python server-side application integrating multiple tools and services for the studio, centralized for Slack access. Automated Jenkins, Perforce, and Unreal Engine notifications.</li>
          <li>Created a bug report tool in Unreal Engine integrating with Jira for automated issue creation.</li>
          <li>Built a custom crash reporting system forwarding Unreal Engine crashes to a backend, logging detailed reports on Slack.</li>
          <li>Integrated ImGui into Unreal Engine with support for custom debug UI using engine reflection flags.</li>
        </ul>
      </div>

      <div>
        <h4>Software Engineer - Beyond Vision (Drone industry) </h4>
        <p><em>August 2021 – November 2023 | Lisbon, Portugal</em></p>
        <ul>
          <li>Implemented multiple embedded firmware applications in C, including data logging and MAVLink protocol communication.</li>
          <li>Worked on Linux kernel drivers to integrate custom hardware platforms.</li>
          <li>Developed real-time systems in ROS (C++ and Python) for sensor data acquisition and flight operations.</li>
          <li>Experience with drone stack: Mavlink, Ardupilot, PX4, QGroundControl, MissionPlanner. Web development, SQL, Android, multimedia.</li>
        </ul>
      </div>

    </section>

    <section id="blog" class="page" style="display:none;">
      <h1>Blog</h1>
      <nav>
        <ul>
          <li><a href="#developing-imgui">Developing an Immediate Mode GUI</a></li>
          <li><a href="#hephaestus">Hepheastus - A table driven code generator</a></li>
          <li><a href="#developing-c-codebase">Developing a C codebase</a></li>
        </ul>
      </nav>

      <hr><hr>

      <article id="developing-imgui">
        <h2>Developing an Immediate Mode GUI</h2>
        <time datetime="2025-10-01">October 21, 2025</time>
        
        <p>
          When working on prototypes, I find that having any sort of UI system is an absolute necessity for iteration speed.
          Once I finally started working on it, I develoepd two rough prototypes. The way I usually go about this is: the first
          iteration of a project is always a naeve implementation to get something working as fast as possible. Very little research goes into it
          and my goal is just to make it happen. See what works, what doesn't, what are the hard problems that I'm solving. The second iteration -
          still in prototype space - is more thoughful, has more research behind it and very obviously tries to improve on the first one.
        </p>
        <p>
          For this UI system, I did the same thing. My main idea was simple. 
          <ol>
            <li>Draw a quad on the screen.</li>
            <li>Trivially check if the cursor was inside.</li>
            <li>Emit events based on what kind of widget this quad represents.</li>
          </ol>
          Find this implementation here:
          <a href="https://github.com/FranciscoZacarias/turtle/blob/master/src/ui.h">ui.h</a>.
          <a href="https://github.com/FranciscoZacarias/turtle/blob/master/src/ui.c">ui.c</a>.
        </p>
        <p>
          For this approach, every widget is built fron the ground up. Every widget has very specific contained logic, which has to be
          re-implemented to every other widget, even if functionality is similar. Take my <code> ui_button </code> and <code> ui_checkbox </code> widget for example:
        </p>
        <pre><code>ui_button(text)
{
  Acquire next rect for button
  Check if mouse is over → highlight → change cursor
  If mouse down → darken
  If mouse clicked → mark clicked
  Lerp color toward target
  Draw button quad
  Draw text centered
  Return if clicked
}</code></pre>
<pre><code>ui_checkbox(text, checkbox)
{
  Acquire next rect for checkbox + label
  Check if mouse is over → highlight → change cursor
  If clicked → toggle checkbox
  Draw small box
  If checked → draw X mark
  Draw text beside box
}</code></pre>
          
      <p>That's a lot of logic for one widget - logic that has to be duplicated for all widgets I want to implement from now on.</p>
      <p>
        Now, I don't have any inherent problem with duplicating code - but the problem is with scale. The more widgets I add and the more functionality I need to support
        the bigger the problem becomes. For example, if I want to add keyboard navigation to my UI system, I would have to go and modify every single widget to support it.
      </p>

      <p>
        After this point, I felt like I had enough of a rough idea of what the problem was. How the global context for the ui module should look like,
        how the cross frame persistance would look like, how input handling would be done, how rendering would be handled... And so I decided to go onto my second iteration.
      </p>

      <strong>Separating builder code from widgets</strong>
      <p>
        After some research, I found a very helpful project - <a href="https://github.com/EpicGamesExt/raddebugger/tree/master/src/ui">raddbg</a> - that implements a UI system that solves the main problem I had.
        The main idea is that there is a separation of concerns when it comes to building widgets and implementing logic. Implementing widgets should be 
        a task more akin to scripting than programming. You just create nodes, define their properties and attach functionality to them, while the bulk of the implementation
        is on building the node itself.
      </p>
      <p>
        With this idea in mind, I started working on my second iteration of the UI system. The main idea is that every node is a quad with some optional text,
        and every node has functionality that can be attached to it. Building widgets becomes almost a scripting task - you just create nodes and attach functionality to them.
        The hard part is implementing the nodes themselves, but once they are implemented, building complex UIs becomes trivial.
      </p>

      <strong>The UI Tree</strong>
      <p>
        To begin with, we need a global context for the UI module that handles all of underlying logic and state management.
        The most important thing we'll keep here is the <code>UI_Node* root</code> node. This node is the root of the UI tree and contains all other nodes as children.
      </p>
      <p>
        And now we need a <code>UI_Node</code>. This is the main structure we will use to build the UI system. From now on, I use this structure
        as the building block for all widgets. Every widget is just a collection of nodes with some attached functionality, so the bulk of the implementation
        will be in building each node. A node structure would look something like this:
      </p>
      <pre><code>typedef struct UI_Node UI_Node;
struct UI_Node
{
  // Node tree
  UI_Node* first; /* First child */
  UI_Node* last;  /* Last child */
  UI_Node* next;  /* Next child, after current node */
  UI_Node* previous; /* Previous child, before current node */
  UI_Node* parent;   /* Parent of current node */

  u64 hash;

  // Node Settings
  Rectf32 bounds;  /* Container rectangle drawing bounds - Absolute values */
  Rectf32 clip;    /* Clipping rectangle for children - Absolute values */
  Vec2f32 cursor;  /* Next position to draw - Relative to node->clip */

  ...

  f32 depth; /* Keeps track of that's in front. Smaller number means closer to the camera. 1 is root */
  UI_Node_Flags flags; /* Behaviour for this node */
  Vec2f32 local_drag_offset; /* How much it was offseted this frame */

  // Style
  ...

  // String stuff
  String8 string;
  ...

};</code></pre>

      <p>
        With this structure, we can build a tree of nodes that represent the UI. As an example, take a look at this window (debug boundaries are turned on for clarity):
      </p>
      <img src="assets/project_showcase/fz_ui_example.PNG"></img>
      <p>At the end of the frame, we would have a UI tree that looks somehting like this:</p>
<pre class="mermaid">
graph TD
  root["__root__"]
  root --> win["Test Window"]
  win --> title["title_bar"]
  win --> row["##layout_x"]
  row --> label["Label"]
  row --> btn["Button 1"]
  row --> cbA_row["##Checkbox a"]
  cbA_row --> cbA["Checkbox a"]
  cbA_row --> cbA_lbl["Checkbox a"]
  win --> col["##layout_y"]
  col --> more["More checkboxes"]
  col --> cbB_row["##Checkbox b"]
  cbB_row --> cbB["Checkbox b"]
  cbB_row --> cbB_lbl["Checkbox b"]
</pre>
      <p>
        Here you can already see the structure that the UI tree will have and how some more complex nodes are structured.
        For example, note the "Test Window" widget. The titlebar it's own node, essentially a child of the window, though it acts as if it belongs to the same widget.
        Buttons are just one node since they essentially are a quad with some text. Checkboxes are two nodes - one for the box and one for the label. And that's the rough idea for this tree structure.
      </p>

      <strong>Building each node</strong>
      <p>
        With this structure in mind, we can start building each node. The main idea is that every node is a quad with some optional text,
        and every node has functionality that can be attached to it. This functionality is attached through flags at createion time.
        For example:
      </p>
      <pre><code>typedef u32 UI_Node_Flags;
enum
{
  UI_Node_Flags_Mouse_Clickable = (1 << 0), /* Makes this node emit a signal when clicked */
  UI_Node_Flags_Draggable = (1 << 1), /* Makes this node emit a signal when dragged */
  UI_Node_Flags_Hoverable = (1 << 2), /* Makes this node emit a signal when hovered */
  UI_Node_Flags_Text_Display = (1 << 3), /* The UI_Node will display the text on the cursor's position and skip the cursor relative to UI_Alignment_Kind */
  UI_Node_Flags_Text_Center_X = (1 << 4), /* If text is displayed, centers the text horizontally in the node */
  UI_Node_Flags_Text_Center_Y = (1 << 5), /* If text is displayed, centers the text vertically in the node */
  UI_Node_Flags_Size_Wrap_Around_Text = (1 << 6), /* Wraps the size of the node around the text with. If fixed size is provided, it is used as padding. */
  UI_Node_Flags_Resize_X = (1 << 7), /* Node can be resized on X axis */
  UI_Node_Flags_Resize_Y = (1 << 8), /* Node can be resized on Y axis */
};</code></pre>
      <p>
        These are some of the behaviour flags you would want to add to a node. 
        Now let's say we're creating a button widget. All we have to do would have to be something like this:
      </p>
      <pre><code>
UI_Node_Flags button_flags =  UI_Node_Flags_Mouse_Clickable |
                              UI_Node_Flags_Hoverable       |
                              UI_Node_Flags_Text_Display    |
                              UI_Node_Flags_Text_Center_Y   |
                              UI_Node_Flags_Text_Center_X   |
                              UI_Node_Flags_Size_Wrap_Around_Text;
ui_node_from_string(text, button_flags);</code></pre>
      <p>
        As you can see here, these flags are attached to the node when created. The resulting node will implement this functionality.
        It becomes almost as if we're configuring a widget, rather than creating one.
        Then inside <code>ui_node_from_string</code> is where we implement the bulk of the logic.
      </p>
      <p>
        A very simplified way of thinking about what this function is doing can be thought of as this:
      </p>
      <pre><code>function UI_Node*
ui_node_from_string(String8 string, UI_Node_Flags flags)
{
  ...

  UI_Node* parent = ui_stack_parent_top(); // Grab the parent node from the stack
  UI_Node* node = push_array(ui_context.frame_arena, UI_Node, 1); // Allocate this node

  // Build the current node
  node->hash              = parent->hash ^ string8_hash(string);
  node->depth             = (node != ui_context.root) ? (parent->depth - F32_EPSILON) : 1.0f;
  node->string            = string8_copy(ui_context.frame_arena, string);
  node->...
  
  // String config
  if (HasFlags(node->flags, UI_Node_Flags_Text_Display))
  {
    // Prepare for text drawing
    if (HasFlags(node->flags, UI_Node_Flags_Text_Center_Y))
    {
      // We align the string vertically
    }
    if (HasFlags(node->flags, UI_Node_Flags_Text_Center_X))
    {
      // We align the string horizontally
    }
  }

  ...

  // Selecting the correct node  
  if (ui_is_mouse_in_node(node))
  {
    if (node->depth < ui_context.hash_hot_depth)
    {
      ui_context.hash_hot       = node->hash;
      ui_context.hash_hot_depth = node->depth;
      if (input_is_button_clicked(&g_input, Mouse_Button_Left))
      {
        ui_context.hash_active       = node->hash;
        ui_context.hash_active_depth = node->depth;
      }
    }
  }
  if (input_is_button_up(&g_input, Mouse_Button_Left) && input_was_button_down(&g_input, Mouse_Button_Left))
  {
    ui_context.hash_active = 0;
    ui_context.hash_active_depth = 1.0f;
  }
  
  // Dragging
  if (ui_context.hash_active == node->hash)
  {
    if (HasFlags(node->flags, UI_Node_Flags_Draggable))
    {
      node->local_drag_offset = g_input.mouse_current.delta;
    }
  }

  return node;
}</code></pre>
      <p>
        This way, the node builds itself based on the flags provided. In this system, there is no such thing as a button for example, only a node that is clickable, hoverable... etc.
      </p>

      <strong>Using stacks for configurability</strong>
      <p>
        Another important aspect of this system is configurability. Every node has a set of properties that define its behaviour and appearance.
        We want some of these properties to propagate down the tree, so that child nodes can inherit properties from their parents. This is achieved by
        having stacks for each property that we want to propagate. For example, we can have a stack for the position of the next node:
      </p>
      <pre><code>typedef struct UI_Context UI_Context;
      struct UI_Context
      {
        ...

        struct UI_Parent_stack
        {
          UI_Node* data[MAX_CONFIG_STACKS];
          u32 top_index;
          UI_Node* bottom_val;
        } parent_stack;
      };</code></pre>
      <p>
        Naturally, everytime we create a new widget, we want to place it somewhere. This way, we can push the position onto the stack and the context will use the top of the stack as the position for the next widget.
        One cool way I found in the source code of <em>raddebugger</em> to do this is through a set of macros that define the start and end of a widget. For example: 
        <pre><code>#define ui_top_left(val) DeferLoop(ui_stack_top_left_push(val), ui_stack_top_left_pop())</code></pre>
        This essentially creates a scope where the top left position is set to <code>val</code>, and when the scope ends, the previous value is restored. So say you want to create a button in a specific position:
      </p>
      <pre><code>ui_top_left(vec2f32(200,200))
        {
          ui_button(S("Test Window"));
        }</code></pre>
      <p>
        This way, internally, <em>vec2f32(200,200)</em> is pushed onto the stack, then when <em>ui_node_from_string(...)</em> is called, it builds the node and it's position by peeking at the top of the top_left stack,
        and assigning that value to the node's position. When the scope of the Defer macro ends, the value is poped from the stack. By the end of the frame, to check for bugs, I like to check if all stacks are at the bottom - meaning all of them were poped correctly. 
      </p>
      <p>
        One worry about this approach is scaling the amount of configurability. Inevitably, this will lead to a huge amount of stacks. While this is obviously achievable, it's mostly boiler plate.
        To deal with this, I use my code generator - <a href="#hephaestus" data-page="blog" class="nav-link">Hephaestus</a> - to generate all of the stack code for me, putting them in a macro, and I just have to call that macro insitde the UI_Context strucutre. This way I don't have to write it by hand.
      </p>

      <strong>Immediate mode <u><em>but</em></u> cross frame persistance</strong>
      <p>
        One problem that we now face is that, if we want to move a node around, we will always have the same position on the stack.
        By design, we don't want the user to have to manage node positions. We just require the initial position. 
        While this is a immediate mode UI system, we still cannot get around the fact we need to store some state between frames.
      </p>
      <p>
        Because we <em>hash</em> every node's string, we can use this hash as a unique identifier for the node. The cache structure only requires the hash and whatever attributes we need to persist between frames, not the full UI_Node.
        In my case, it looks something like this:
      </p>
      <pre><code>typedef struct UI_Node_Cache UI_Node_Cache;
struct UI_Node_Cache
{
  u64 hash;
  ...
}</pre></code>
      <p>
        This then can be stored in a hash table, where every frame we look for the node's hash in the table. 
        To solve this positioning problem, we can store an offset position (which is the mouse cursor delta we collected while clicking on a draggable node) in the cache, that way, when we create the node again next frame,
        we can just add this offset to the initial position to get the new position. This way the stack has a static reference value provided by the user, and the cache provides the dynamic offset value that we collect while interacting with the node.
      </p>
      <strong>Cross frame transitions</strong>
      <p>
        This is also usefull for transitions for example. I like to have some smooth color transitions when clicking or hovering nodes.
        We can achieve this in the same way by storing a linear interpolation factor in the cache that we update every frame based on the node's state (hovered, clicked... etc).
      </p>
      <pre><code>typedef struct UI_Node_Cache UI_Node_Cache;
struct UI_Node_Cache
{
  u64 hash;
  Vec2f32 accumulated_drag_offset; /* How much it has been offseted in total */
  f32 hover_t;
  f32 active_t;
};</code></pre>
      <p>
        And then we can interpolate between the colors - by a given speed - based on these values:
      </p>
      <pre><code>// Hover
if (HasFlags(node->flags, UI_Node_Flags_Hoverable))
{
  if (ui_context.hash_hot == node->hash)
  {
    cached_node->hover_t = Clamp(cached_node->hover_t + g_delta_time * ui_context.animation_speed, 0, 1);
  }
  else
  {
    cached_node->hover_t = Clamp(cached_node->hover_t - g_delta_time * ui_context.animation_speed, 0, 1);
  }
}

// Active
if (HasFlags(node->flags, UI_Node_Flags_Mouse_Clickable))
{
  if (ui_context.hash_active == node->hash)
  {
    cached_node->active_t = Clamp(cached_node->active_t + g_delta_time * ui_context.animation_speed, 0, 1);
  }
  else
  {
    cached_node->active_t = Clamp(cached_node->active_t - g_delta_time * ui_context.animation_speed, 0, 1);
  }
}</code></pre>
      <p>
        The result would look something like this:
      </p>
      <img src="assets/project_showcase/fz_ui_transitions.gif"></img>
      <p>

      </p>

      <strong>Building each widget</strong>
      <p>
        With this setup, building each widget becomes a matter of creating nodes with the correct flags and properties.
        Take the full button implementation for example:
      </p>
      <pre><code>function UI_Signal
ui_button(String8 text)
{
  UI_Signal button_signal = (UI_Signal){0};
  {
    ui_node_color_scheme(ui_context.color_scheme.button)
    ui_child_layout_kind(UI_Alignment_Kind_X)
    ui_padding_fixed(0)
    ui_size_fixed(20, ui_context.text_pixel_height - ui_context.default_widget_height)
    {
      UI_Node_Flags button_flags = UI_Node_Flags_Mouse_Clickable |
                                   UI_Node_Flags_Hoverable       |
                                   UI_Node_Flags_Text_Display    |
                                   UI_Node_Flags_Text_Center_Y   |
                                   UI_Node_Flags_Text_Center_X   |
                                   UI_Node_Flags_Size_Wrap_Around_Text;
      button_signal.node  = ui_node_from_string(text, button_flags);
      ui_fill_signals_from_node(&button_signal);
    }
  }
  return button_signal;
}</code></pre>
      <p>
        Creating a button is a matter of setting up some configuration (color scheme, layout kind, padding, size) and then assigning the expected behaviour flags.
        You can have more complex widgets, such as a window for example, which would be a collection of nodes with specific behaviour.
        In order for the child nodes to inherit properties from the window node, the window cannot just be one function call. We have to define a begin and end function:
      </p>
      <pre><code>function void
ui_window_begin(String8 text)
{
  UI_Signal window_signal = (UI_Signal){0};
  {
    ui_node_color_scheme(ui_context.color_scheme.window)
    ui_child_layout_kind(UI_Alignment_Kind_Y)
    {
      UI_Node_Flags window_flags = 0;
      String8 window_text = Sf(ui_context.frame_arena, ""S_FMT"##_window_", S_ARG(text));
      window_signal.node = ui_node_from_string(window_text, window_flags);
      ui_stack_parent_push(window_signal.node);
    }
  }

  UI_Signal title_bar_signal = (UI_Signal){0};
  {
    ui_node_color_scheme(ui_context.color_scheme.title_bar)
    ui_child_layout_kind(UI_Alignment_Kind_X)
    ui_padding_fixed(2)
    ui_size_kind_x(UI_Size_Kind_Relative) ui_size_relative_x(1)
    ui_size_kind_y(UI_Size_Kind_Relative) ui_size_relative_y(0.08)
    {
      UI_Node_Flags title_bar_flags = UI_Node_Flags_Mouse_Clickable |
                                      UI_Node_Flags_Hoverable       |
                                      UI_Node_Flags_Draggable       |
                                      UI_Node_Flags_Text_Display    |
                                      UI_Node_Flags_Text_Center_Y;
      String8 window_title_bar_text = Sf(ui_context.frame_arena, ""S_FMT"##_title_bar_", S_ARG(text));
      title_bar_signal.node = ui_node_from_string(window_title_bar_text, title_bar_flags);
    }
  }
}

function void
ui_window_end()
{
  UI_Node* node = ui_stack_parent_pop();
  Vec2f32 offset = {0};
  if (ui_find_first_drag_offset(node, &offset))
  {
    ui_apply_drag_offset(node, offset);
  }
  ui_update_tree_nodes(node);
}</code></pre>

      <p>
        This makes us push the <em>window context</em> to the stack as a parent of all nodes created in between the start and end.
        As we've seen before, this is another great opportunity to make use of the Defer macro, where we all the nodes called inside the Defer macro scope, will be children of the window:
      </p>
      <pre><code>ui_begin();
ui_top_left(vec2f32(200,200))
ui_size_fixed_x(200) ui_size_fixed_y(200)
ui_window(S("Test Window"))
{
  ui_padding_fixed(5)
  ui_row(S("Test Row"), 100)
  {
    ui_label(S("Label"));
    ui_button(S("Button 1"));
    ui_checkbox(S("Checkbox a"), &a);
  }
  ui_padding_fixed(5)
  ui_column(S("Test column"), 200)
  {
    ui_label(S("More checkboxes"));
    ui_checkbox(S("Checkbox b"), &b);
  }
}
ui_end();</code></pre>

      <p>
        My implementation of this system can be found at: <a href="https://github.com/FranciscoZacarias/fz_ui">fz_ui</a>.
        Being a prototype, this is a rough implementation. There are many missing features and some bugs. But overall, I'm happy with the results and I will continue to iterate on similar systems in other projects.
      </p>

      </article>

      <hr><hr>

      <!-- hephaestus article -->
      <article id="hephaestus">
        <h2>Hephaestus - A table driven code generator</h2>
        <time datetime="2025-10-01">October 10, 2025</time>

        <p>
          <strong>Hephaestus</strong> is a table-driven text generator heavily inspired by
          <a href="https://www.rfleury.com/p/table-driven-code-generation">this article</a>.
          It defines structured data tables and generation templates for text generation.
          The goal is speed, simplicity, and direct C integration with no external runtime dependencies.
        </p>

        <hr>

        <h3>1. Global Scopes</h3>

        <h4>@config</h4>
        <p>
          The <code>@config</code> block defines global configuration parameters for the generation process.
          These can be referenced anywhere in the file.
        </p>

        <pre><code>@config
{
  @output_file_name `test_file`
  @output_path `../src/generated/`
}</code></pre>

        <p><strong>Supported keys:</strong></p>
        <ul>
          <li><code>@output_file_name</code> - Name of the generated file (without extensions). Hephaestus appends <code>.hephaestus.&lt;ext&gt;</code> based on the generator type.</li>
          <li><code>@output_path</code> - Relative or absolute path to the output directory.</li>
        </ul>

        <p>More configuration options may be added later.</p>

        <hr>

        <h3>2. Table Definition</h3>
        <p>
          The <code>@table</code> block defines structured data rows used by generators.
          Each row becomes a data record that can be referenced in <code>@generate</code> blocks.
        </p>

        <pre><code>@table // Defines stacks for different types
Stack_Table (name type default_value max)
{
  { node              UI_Node*             (UI_Node){0}                   32 }
  { top_left          Vec2f32              `vec2f32(0.0f, 0.0f)`          32 }
  { size_x            f32                   g_os_window.dimensions.x      32 }
  { size_y            f32                   g_os_window.dimensions.y      32 }
  { spacing_y         f32                   0.0f                          32 }
  { alignment_kind    UI_Alignment_Kind    UI_Alignment_Kind_Y            32 }
  { width_kind        UI_Width_Kind        UI_Width_Kind_Fill             32 }
  { height_kind       UI_Height_Kind       UI_Height_Kind_Fill            32 }
  { node_color_scheme UI_Node_Color_Scheme ui_context.color_scheme.window 32 }
  { border_color      Color                PURPLE(1)                      32 }
  { background_color  Color                PURPLE(1)                      32 }
}</code></pre>

        <ul>
          <li><code>Stack_Table</code> - table name.</li>
          <li><code>(name type default_value max)</code> - column headers.</li>
          <li>Each <code>{ ... }</code> entry defines one data row.</li>
        </ul>

        <hr>

        <h3>3. Code Generation</h3>
        <p>
          A <code>@generate</code> block defines a text output template. It can contain static text, loops, and variable interpolations.
          The generator type determines the output file extension (e.g. <code>@generate @c_file</code> or <code>@generate @h_file</code>).
        </p>

        <pre><code>@generate @c_file
{
  `// @Hephaestus generated code $(@time_now) \n\n`
  @foreach(Stack_Table) `// Row $(@index)\ntypedef struct $(name) $(name);\nstruct $(name)_stack\n{\n  $(type) data[$(max)];\n  u32 top_index;\n  $(type) bottom_val;\n};\n\n\n`
}</code></pre>

        <p><strong>Notes:</strong></p>
        <ul>
          <li>Static text is wrapped in backticks.</li>
          <li><code>@foreach(TableName)</code> repeats its inner content for each row in that table.</li>
          <li>Variable substitution uses <code>$()</code>.</li>
        </ul>

        <hr>

        <h3>4. Implicit Variables</h3>
        <p>Hephaestus automatically provides certain implicit variables:</p>
        <table>
          <thead>
            <tr>
              <th>Variable</th>
              <th>Description</th>
              <th>Example Output</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>@index</code></td>
              <td>Current iteration index during a <code>@foreach</code></td>
              <td>0, 1, 2, ...</td>
            </tr>
            <tr>
              <td><code>@time_now</code></td>
              <td>Current timestamp when generation runs</td>
              <td>2025-October-08 14:27:56</td>
            </tr>
          </tbody>
        </table>
        <p>New implicit variables may be introduced in future versions.</p>

        <hr>

        <h3>5. Variable Substitution and Operations</h3>
        <p>
          You can reference table or config values using <code>$(variable)</code> inside a <code>@generate</code> block.
          Simple arithmetic and string slicing operations are supported.
        </p>

        <h4>Numeric Expansion</h4>
        <pre><code>// If $(max) = 32:
$(max+1) → 33
$(max-1) → 31</code></pre>

        <h4>String Expansion</h4>
        <pre><code>// If $(name) = "Node":
$(name+1) → "ode"
$(name-1) → "Nod"</code></pre>

        <hr>

        <h3>6. Generation Example</h3>
        <p>Below is are two complete example of input DSL and the generated C output:</p>

        <h4>Input DSL for generating multiple structures (using previously defined Stack_Table):</h4>
        <pre><code>@generate @c_file
{
  `// @Hephaestus generated code $(@time_now) \n\n`
  @foreach(Stack_Table) `// Row $(@index)\ntypedef struct $(name) $(name);\nstruct $(name)_stack\n{\n  $(type) data[$(max)];\n  u32 top_index;\n  $(type) bottom_val;\n};\n\n\n`
}</code></pre>

        <h4>Generated Output</h4>
        <pre><code>// @Hephaestus generated code 2025-October-08 15:53:23 

// Row 0
typedef struct node node;
struct node_stack
{
  UI_Node* data[32];
  u32 top_index;
  UI_Node* bottom_val;
};

// Row 1
typedef struct top_left top_left;
struct top_left_stack
{
  Vec2f32 data[32];
  u32 top_index;
  Vec2f32 bottom_val;
};

// Row 2
typedef struct size_x size_x;
struct size_x_stack
{
  f32 data[32];
  u32 top_index;
  f32 bottom_val;
};

...</code></pre>

        <h3>6.1 Generation Example 2</h3>
        <h4>Input DSL for generating a bit flag enum:</h4>
        <pre><code>@table
UI_Node_Flags_Table
  (name documentation)
{
  { Mouse_Clickable          `Makes the node clickable`    }
  { Display_Text             `Node shows text`             }
  { Draggable                `TODO(fz): Add documentation` }
  { Hoverable                `TODO(fz): Add documentation` }
  { Center_Text_Horizontally `TODO(fz): Add documentation` }
  { Center_Text_Vertically   `TODO(fz): Add documentation` }
  { Dimensions_Wrap_Text     `TODO(fz): Add documentation` }
}
</code></pre>

        <h4>Template for bitflag enum using the $(index) variable:</h4>
        <pre><code>@generate @h_file
{
  `typedef u32 UI_Node_Flags;\n`
  `enum\n{\n`
  @foreach(UI_Node_Flags_Table) `  UI_Node_Flags_$(name) = (1 << $(@index)), /* $(documentation) */\n`
  `};\n\n`
}</code></pre>

        <h4>Generated Output</h4>
        <pre><code>typedef u32 UI_Node_Flags;
enum
{
  UI_Node_Flags_Mouse_Clickable = (1 << 0), /* Makes the node clickable */
  UI_Node_Flags_Display_Text = (1 << 1), /* Node shows text */
  UI_Node_Flags_Draggable = (1 << 2), /* TODO(fz): Add documentation */
  UI_Node_Flags_Hoverable = (1 << 3), /* TODO(fz): Add documentation */
  UI_Node_Flags_Center_Text_Horizontally = (1 << 4), /* TODO(fz): Add documentation */
  UI_Node_Flags_Center_Text_Vertically = (1 << 5), /* TODO(fz): Add documentation */
  UI_Node_Flags_Dimensions_Wrap_Text = (1 << 6), /* TODO(fz): Add documentation */
};</code></pre>

      </article>

      <hr><hr>

      <article id="developing-c-codebase">
        <h2>Developing my C codebase</h2>
        <time datetime="2025-10-10">October 10, 2025</time>

        <section>
          <h3>Motivation</h3>
          <p>I needed a focused C codebase to avoid external runtime layers and heavy clib dependencies. Everything is explicit. Allocations, logging, OS interfaces...
            Most importantly, I have full ownership of the code. I can audit it quickly and understand all the moving parts, modify and extend the API as needed.
          </p>
        </section>

        <section>
          <h3>Memory: Arenas and scratch arenas</h3>
          <p>All heap-style allocation uses <code>Arena</code> objects. Arenas reserve a contiguous range, commit pages on demand, and maintain a single growing position. Pop is explicit and cheap.</p>

          <pre><code>// core arena API (excerpt)
Arena* arena = arena_alloc(); // allocate a new arena
Mat4f32* mat = push_array(arena, Mat4f32, 1); // allocate one Mat4f32</code></pre>

          <p>One of the most convinent things about this style of allocation is that, by necessity, functions that require a memory allocation will ask for an Arena* in their arguments - so the caller
            is always aware when a function will make an allocation and is in control over that allocation's lifetime. </p>
          <p>E.g:</p>
          <pre><code>function String8
string8_copy(Arena* arena, String8 source)
{
  String8 result;
  result.size = source.size;
  result.str  = push_array(arena, u8, result.size);
  MemoryCopy(result.str, source.str, result.size);
  return result;
}</code></pre>

          <p>Can also be used to create scoped scratch arenas via the thread-local context. They're lifetime stretches between <code>scratch_begin(0,0)</code> and <code>scratch_end(&scratch)</code>. Because deallocating arenas is as cheap as moving a pointer around, this operation is as cheap is it gets for memory allocations.</p>

          <pre><code>// scratch usage
{
  Scratch scratch = scratch_begin(conflicts, count);
  T* temp = push_array(scratch.arena, T, n);
  // use scratch arena for temporary allocations...
  scratch_end(&scratch);
}</code></pre>
        </section>

        <section>
          <h3>Strings: String8 (immutable by convention)</h3>
          <p>Strings are 8-bit length-prefixed views. They are not owning by default. Treat them as immutable slices. Copy or allocate into an arena if you need ownership.</p>

          <pre><code>typedef struct String8 String8;
struct String8 {
  u64 size;
  u8* str;
};
#define S(s) (String8){sizeof(s)-1, (u8*)(s)}
#define Sf(arena,fmt,...) string8_from_format(arena, fmt, __VA_ARGS__)</code></pre>

          <p>String helpers return <code>String8</code>. If you need permanent storage use <code>push_array</code> into an arena or use arena-based format helpers.</p>
        </section>

        <section>
          <h3>Error handling and logging</h3>
          <p>Logging is explicit and arena-backed. Errors are logged as entries with timestamp, file, and line. The log context stores entries in an arena to avoid dynamic allocations when reporting failures.</p>

          <pre><code>typedef enum { Log_Level_Info, Log_Level_Warning, Log_Level_Error, Log_Level_Fatal } Log_Level;
struct Log_Entry { Log_Level level; String8 message; String8 file; u32 line; OS_Date_Time timestamp; };
global Log_Context g_log_context;
function void log_init(String8 error_log_path);
function void log_emit(Log_Level level, String8 message, String8 file, u32 line);
#define emit_error(str8_msg) log_emit(Log_Level_Error, str8_msg, S(__FILE__), __LINE__)</code></pre>

          <p>Design rule: emit logs, but don’t rely on them to free resources. Use them to diagnose and exit or continue deterministically.</p>
        </section>

        <section>
          <h3>OS abstraction and entry point</h3>
          <p>The code separates platform-specific pieces behind a small OS API. That API covers console I/O, window creation, OpenGL hookup, and memory page operations. The app code calls a single standard entry point and the platform layer adapts.</p>

          <pre><code>// portable entry point
function void
main_thread_base_entry_point(int argc, char **argv)
{
  os_time_init();

  // Setup log system
  {
    Scratch scratch = scratch_begin(0, 0);
    String8 log_path = os_executable_path(scratch.arena);
    log_path = os_directory_pop(log_path); // Pop the applicatin.exe file
    log_path = os_directory_pop(log_path); // Pop from build directory
    log_init(log_path);
    emit_info(S(">>>> Entry point <<<<"));
    scratch_end(&scratch);
  }

  Command_Line cmd_line = command_line_parse_from_argc_argv(argc, argv);
  entry_point(&cmd_line);
}</code></pre>

          <p>The user has to then implement <code>function void entry_point(Command_Line* command_line)</code> as the application's entry point</p>

          <p>Platform layer responsibilities:</p>
          <ul>
            <li>Map native event loop to the base entry point.</li>
            <li>Create windows and graphical contexts where required.</li>
            <li>Provide page-size and virtual memory helpers used by arenas.</li>
            <li>Parse platform argc/argv into <code>Command_Line</code>.</li>
          </ul>
        </section>

        <section>
          <h3>Command line parsing</h3>
          <p>Command line parsing yields a fixed-size array of args. Flags and key/value pairs are clearly separated. The parser returns a <code>Command_Line</code> struct backed by <code>String8</code> slices.</p>

          <pre><code> struct Command_Line
{
  String8 executable;
  String8 raw_args;
  Command_Line_Arg args[MAX_COMMAND_LINE_ARGS];
  u32 args_count;
};
function Command_Line command_line_parse_from_argc_argv(s32 argc, u8** argv);
          </code></pre>
        </section>

        <section>
          <h3>How to use it, concisely</h3>
          <ol>
            <li>Initialize OS layer and thread context.</li>
            <li>Create arenas for long-lived storage and caches.</li>
            <li>Use scratch arenas for short-lived temporaries.</li>
            <li>Use <code>String8</code> as view types, allocate into arenas when ownership is needed.</li>
            <li>Log via <code>log_emit</code>. React to fatal logs deterministically.</li>
            <li>Keep platform-specific code isolated behind small OS APIs.</li>
          </ol>
        </section>

        <section>
          <h3>Design constraints and tradeoffs</h3>
          <p>Tradeoffs made deliberately:</p>
          <ul>
            <li>No dynamic object lifecycle managers. You manage lifetimes via arenas and scope.</li>
            <li>Limited convenience functions. Explicit over implicit operations.</li>
          </ul>
        </section>

        <section>
          <h3>Example full snippet</h3>
          <p>Minimal startup sketch showing the pieces together.</p>

          <pre><code>#include "fz_base.h"

function void
input_update()
{
  if (input_is_key_pressed(Keyboard_Key_ESCAPE))
  {
    os_exit_process(0);
  }
}

function void
entry_point(Command_Line* command_line)
{
  Arena* arena = arena_alloc();

  os_console_init();
  os_window_init(400, 400, S("fz_std_tests"));
  os_opengl_init();
  os_window_open();

  f32 phase = 0.0f;
  const f32 speed = 0.05f;
  const f32 tau = PI*2;

  os_window_enable_vsync(true);
  while(os_is_application_running())
  {
    input_update();

    phase += speed;
    if (phase > tau) phase -= tau;
    f32 t = (1.0f + cosf(phase)) * 0.5f;
    f32 r = (1.0f + cosf(phase)) * 0.5f;
    f32 g = (1.0f + cosf(phase - tau/3)) * 0.5f;
    f32 b = (1.0f + cosf(phase - 2*tau/3)) * 0.5f;
    glClearColor(r, g, b, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

    os_swap_buffers();
  }
}</code></pre>
        </section>
        <hr>
        <section>
          <p>This codebase is everchanging. Every project I form new opinions and I'm not afraid of implementing and trying them. The most important thing for me is that it suits my programming style. It is not designed to be used by anyone but me.
            I strive for it to fit projects that need explicit control. It brings me joy.</p>
        </section>
      </article>
    </section>
  </main>

  <footer>
    <div class="footer-content">
      <span>
        &copy; Francisco Zacarias
      </span>
      <span class="social-icons">
        <a href="https://github.com/FranciscoZacarias" target="_blank" aria-label="GitHub">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 0C5.37 0 0 5.37 0 12c0 5.3 3.438 9.8 8.205 11.385.6.113.82-.263.82-.583 0-.288-.012-1.244-.018-2.44-3.338.724-4.042-1.61-4.042-1.61-.546-1.385-1.334-1.753-1.334-1.753-1.09-.745.082-.73.082-.73 1.205.085 1.84 1.237 1.84 1.237 1.07 1.834 2.805 1.304 3.49.997.108-.775.418-1.305.762-1.605-2.665-.305-5.466-1.333-5.466-5.932 0-1.31.468-2.382 1.235-3.222-.124-.303-.536-1.527.117-3.176 0 0 1.008-.322 3.3 1.23.957-.266 1.984-.398 3.003-.403 1.02.005 2.047.137 3.006.403 2.288-1.552 3.295-1.23 3.295-1.23.655 1.649.243 2.873.12 3.176.77.84 1.233 1.912 1.233 3.222 0 4.61-2.807 5.624-5.479 5.921.43.37.815 1.096.815 2.21 0 1.596-.015 2.884-.015 3.275 0 .323.218.7.825.581C20.565 21.796 24 17.3 24 12c0-6.63-5.37-12-12-12z"/>
          </svg>
        </a>
        <a href="https://www.linkedin.com/in/franciscozacarias/" target="_blank" aria-label="LinkedIn">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path d="M22.23 0H1.77C.79 0 0 .774 0 1.727v20.545C0 23.226.79 24 1.77 24h20.46c.98 0 1.77-.774 1.77-1.727V1.727C24 .774 23.21 0 22.23 0zM7.08 20.452H3.548V9h3.532v11.452zM5.314 7.57a2.046 2.046 0 1 1 0-4.092 2.046 2.046 0 0 1 0 4.092zM20.452 20.452h-3.53v-5.605c0-1.336-.026-3.054-1.86-3.054-1.86 0-2.144 1.45-2.144 2.948v5.711h-3.53V9h3.392v1.561h.05c.472-.895 1.628-1.838 3.353-1.838 3.585 0 4.245 2.36 4.245 5.428v6.3z"/>
          </svg>
        </a>
        <a href="https://www.youtube.com/@fzac" target="_blank" aria-label="YouTube">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path d="M23.498 6.186a2.964 2.964 0 0 0-2.084-2.09C19.7 3.5 12 3.5 12 3.5s-7.7 0-9.414.596a2.964 2.964 0 0 0-2.084 2.09A30.132 30.132 0 0 0 0 12a30.132 30.132 0 0 0 .502 5.814 2.964 2.964 0 0 0 2.084 2.09C4.3 20.5 12 20.5 12 20.5s7.7 0 9.414-.596a2.964 2.964 0 0 0 2.084-2.09A30.132 30.132 0 0 0 24 12a30.132 30.132 0 0 0-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
          </svg>
        </a>
      </span>
    </div>
  </footer>
</body>

<script>
  var nav_links = document.querySelectorAll("a[data-page]");
  var pages = document.getElementsByClassName("page");

  function show_page(page_id) {
    var i;
    for (i = 0; i < pages.length; i = i + 1) {
      if (pages[i].id === page_id) {
        pages[i].style.display = "block";
      } else {
        pages[i].style.display = "none";
      }
    }

    for (i = 0; i < nav_links.length; i = i + 1) {
      if (nav_links[i].getAttribute("data-page") === page_id) {
        nav_links[i].className = "nav-link active";
      } else {
        nav_links[i].className = "nav-link";
      }
    }

    location.hash = page_id;
  }

  var i;
  for (i = 0; i < nav_links.length; i = i + 1) {
    nav_links[i].addEventListener("click", function (e) {
      e.preventDefault();
      show_page(this.getAttribute("data-page"));
    });
  }

  var blog_links = document.querySelectorAll("#blog nav a");
  for (i = 0; i < blog_links.length; i = i + 1) {
    blog_links[i].addEventListener("click", function (e) {
      e.preventDefault();
      var target_id = this.getAttribute("href").substr(1);
      var target = document.getElementById(target_id);
      if (target) {
        target.scrollIntoView({ behavior: "smooth" });
      }
    });
  }

  var page = "home";
  if (location.hash && location.hash.length > 1) {
    page = location.hash.substr(1);
  }

  show_page(page);

  window.onhashchange = function () {
    var page = "home";
    if (location.hash && location.hash.length > 1) {
      page = location.hash.substr(1);
    }
    show_page(page);
  };
</script>

<style>
  @font-face {
    font-family: 'Karmina';
    src: url('assets/fonts/Karmina.otf') format('opentype');
    font-weight: normal;
    font-style: normal;
  }

  html {
    scroll-behavior: smooth;
  }

  html,
  body {
    margin: 0;
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    font-family: 'Karmina', sans-serif;
  }

  header {
    text-align: center;
    padding: 1rem;
    background: #f5f5f5;
  }

  nav a {
    margin: 0 1rem;
    text-decoration: none;
    color: black;
  }

  nav a.active {
    font-weight: bold;
    text-decoration: underline;
  }

  main {
    flex: 1;
    max-width: 800px;
    margin: 2rem auto;
    padding: 0 1rem;
  }

  footer {
    text-align: center;
    padding: 1rem;
    background: #f5f5f5;
  }

  .social-icons a {
    margin: 0 0.1rem;
    color: black;
    text-decoration: none;
  }

  .footer-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 0.1rem;
  }

  .social-icons a {
    margin: 0 0.3rem;
    color: black;
    text-decoration: none;
    transition: color 0.2s;
  }

  .social-icons a:hover {
    color: #0073b1;
  }

  .social-icons svg {
    width: 16px;
    height: 16px;
    vertical-align: middle;
  }

  article h2 {
    margin: 0 0 0.2em 0;
    /* tiny margin below title */
  }

  article time {
    display: block;
    font-size: 0.9em;
    color: #666;
    margin: 0;
    /* no extra margin */
  }

  article p {
    margin: 0.4em 0 1em 0;
    /* small margin above paragraph */
  }

  code {
    border: 2px solid #ccc;
    background-color: #ececec;
    padding: 0.2em 0.4em;
    border-radius: 8px;
    font-family: monospace;
  }

  pre code {
    display: block;
    padding: 1em;
    overflow-x: auto;
  }

  .cv-gif {
    display: block;
    margin-top: 0.5em;
    max-width: 100%;
    border: 2px solid #ccc;
    background-color: #f5f5f5;
    border-radius: 6px;
    padding: 6px;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    margin: 1em 0;
    font-size: 0.95rem;
  }

  th, td {
    border: 1px solid #ccc;
    padding: 6px 10px;
    text-align: left;
  }

  th {
    background-color: #f5f5f5;
    font-weight: 600;
  }

  tr:nth-child(even) {
    background-color: #fafafa;
  }
</style>

</html>
